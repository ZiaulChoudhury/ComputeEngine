/*
 * Generated by Bluespec Compiler (build f2da894e)
 * 
 * On Sat Jul 17 19:53:59 IST 2021
 * 
 */
#include "bluesim_primitives.h"
#include "mkFlowTest.h"
#include "imported_BDPI_functions.h"


/* Literal declarations */
static unsigned int const UWide_literal_512_haaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa_arr[] = { 2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u,
																							2863311530u };
static tUWide const UWide_literal_512_haaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(512u,
																					UWide_literal_512_haaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa_arr);
static unsigned int const UWide_literal_480_h0_arr[] = { 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u,
							 0u };
static tUWide const UWide_literal_480_h0(480u, UWide_literal_480_h0_arr);


/* String declarations */
static std::string const __str_literal_1("%d", 2u);


/* Constructor */
MOD_mkFlowTest::MOD_mkFlowTest(tSimStateHdl simHdl, char const *name, Module *parent)
  : Module(simHdl, name, parent),
    __clk_handle_0(BAD_CLOCK_HANDLE),
    INST_cId(simHdl, "cId", this, 32u, 0u, (tUInt8)0u),
    INST_col(simHdl, "col", this, 32u, 0u, (tUInt8)0u),
    INST_count(simHdl, "count", this, 32u, 0u, (tUInt8)0u),
    INST_cx(simHdl, "cx", this, 32u, 0u, (tUInt8)0u),
    INST_img(simHdl, "img", this, 32u, 0u, (tUInt8)0u),
    INST_init(simHdl, "init", this, 1u, (tUInt8)0u, (tUInt8)0u),
    INST_load(simHdl, "load", this, 1u, (tUInt8)0u, (tUInt8)0u),
    INST_px(simHdl, "px", this),
    PORT_RST_N((tUInt8)1u),
    DEF_px_get___d31(512u),
    DEF__0_CONCAT_readInput_cx_5_7___d28(512u)
{
  symbol_count = 14u;
  symbols = new tSym[symbol_count];
  init_symbols_0();
}


/* Symbol init fns */

void MOD_mkFlowTest::init_symbols_0()
{
  init_symbol(&symbols[0u], "cId", SYM_MODULE, &INST_cId);
  init_symbol(&symbols[1u], "col", SYM_MODULE, &INST_col);
  init_symbol(&symbols[2u], "count", SYM_MODULE, &INST_count);
  init_symbol(&symbols[3u], "cx", SYM_MODULE, &INST_cx);
  init_symbol(&symbols[4u], "img", SYM_MODULE, &INST_img);
  init_symbol(&symbols[5u], "init", SYM_MODULE, &INST_init);
  init_symbol(&symbols[6u], "load", SYM_MODULE, &INST_load);
  init_symbol(&symbols[7u], "px", SYM_MODULE, &INST_px);
  init_symbol(&symbols[8u], "RL_configure", SYM_RULE);
  init_symbol(&symbols[9u], "RL_cyccount", SYM_RULE);
  init_symbol(&symbols[10u], "RL_load_config", SYM_RULE);
  init_symbol(&symbols[11u], "RL_receive", SYM_RULE);
  init_symbol(&symbols[12u], "RL_send", SYM_RULE);
  init_symbol(&symbols[13u], "x__h678", SYM_DEF, &DEF_x__h678, 32u);
}


/* Rule actions */

void MOD_mkFlowTest::RL_cyccount()
{
  tUInt32 DEF_count_PLUS_1___d2;
  DEF_x__h678 = INST_count.METH_read();
  DEF_count_PLUS_1___d2 = DEF_x__h678 + 1u;
  INST_count.METH_write(DEF_count_PLUS_1___d2);
}

void MOD_mkFlowTest::RL_load_config()
{
  if (!(PORT_RST_N == (tUInt8)0u))
    initialize();
  INST_load.METH_write((tUInt8)1u);
}

void MOD_mkFlowTest::RL_configure()
{
  tUInt32 DEF_cId_PLUS_1___d14;
  tUInt32 DEF_b__h563;
  tUInt8 DEF_cId_EQ_270___d11;
  tUInt32 DEF_readConfig_cId_BITS_15_TO_0___d10;
  tUInt32 DEF_b__h425;
  tUInt32 DEF_readConfig_cId___d9;
  DEF_b__h425 = INST_cId.METH_read();
  DEF_readConfig_cId___d9 = readConfig(DEF_b__h425);
  DEF_readConfig_cId_BITS_15_TO_0___d10 = (tUInt32)(65535u & DEF_readConfig_cId___d9);
  DEF_cId_EQ_270___d11 = DEF_b__h425 == 270u;
  DEF_b__h563 = (((tUInt32)((tUInt8)0u)) << 26u) | (tUInt32)(DEF_readConfig_cId___d9 >> 6u);
  DEF_cId_PLUS_1___d14 = DEF_b__h425 + 1u;
  INST_px.METH_loadConfig(DEF_readConfig_cId_BITS_15_TO_0___d10);
  if (DEF_cId_EQ_270___d11)
    INST_init.METH_write((tUInt8)1u);
  if (DEF_cId_EQ_270___d11)
    INST_img.METH_write(DEF_b__h563);
  INST_cId.METH_write(DEF_cId_PLUS_1___d14);
  INST_load.METH_write((tUInt8)0u);
}

void MOD_mkFlowTest::RL_send()
{
  tUInt32 DEF_cx_5_PLUS_1___d26;
  tUInt32 DEF_b__h735;
  tUInt32 DEF_x__h2722;
  DEF_b__h735 = INST_cx.METH_read();
  DEF_x__h2722 = readInput(DEF_b__h735);
  DEF__0_CONCAT_readInput_cx_5_7___d28.set_whole_word(UWide_literal_480_h0.get_whole_word(14u),
						      15u).set_whole_word(UWide_literal_480_h0.get_whole_word(13u),
									  14u).set_whole_word(UWide_literal_480_h0.get_whole_word(12u),
											      13u).set_whole_word(UWide_literal_480_h0.get_whole_word(11u),
														  12u).set_whole_word(UWide_literal_480_h0.get_whole_word(10u),
																      11u).set_whole_word(UWide_literal_480_h0.get_whole_word(9u),
																			  10u).set_whole_word(UWide_literal_480_h0.get_whole_word(8u),
																					      9u).set_whole_word(UWide_literal_480_h0.get_whole_word(7u),
																								 8u).set_whole_word(UWide_literal_480_h0.get_whole_word(6u),
																										    7u).set_whole_word(UWide_literal_480_h0.get_whole_word(5u),
																												       6u).set_whole_word(UWide_literal_480_h0.get_whole_word(4u),
																															  5u).set_whole_word(UWide_literal_480_h0.get_whole_word(3u),
																																	     4u).set_whole_word(UWide_literal_480_h0.get_whole_word(2u),
																																				3u).set_whole_word(UWide_literal_480_h0.get_whole_word(1u),
																																						   2u).build_concat((((tUInt64)(UWide_literal_480_h0.get_whole_word(0u))) << 32u) | (tUInt64)(DEF_x__h2722),
																																								    0u,
																																								    64u);
  DEF_cx_5_PLUS_1___d26 = DEF_b__h735 + 1u;
  INST_cx.METH_write(DEF_cx_5_PLUS_1___d26);
  INST_px.METH_put(DEF__0_CONCAT_readInput_cx_5_7___d28);
}

void MOD_mkFlowTest::RL_receive()
{
  tUInt32 DEF_col_4_PLUS_1___d35;
  tUInt8 DEF_col_4_EQ_63503___d36;
  tUInt32 DEF_b__h5666;
  tUInt32 DEF_signed_px_get_1_BITS_15_TO_6_2___d33;
  tUWide DEF_AVMeth_px_get(512u, false);
  DEF_b__h5666 = INST_col.METH_read();
  DEF_col_4_EQ_63503___d36 = DEF_b__h5666 == 63503u;
  DEF_col_4_PLUS_1___d35 = DEF_b__h5666 + 1u;
  DEF_AVMeth_px_get = INST_px.METH_get();
  DEF_px_get___d31 = DEF_AVMeth_px_get;
  DEF_signed_px_get_1_BITS_15_TO_6_2___d33 = DEF_px_get___d31.get_bits_in_word32(0u, 6u, 10u);
  if (!(PORT_RST_N == (tUInt8)0u))
  {
    dollar_write(sim_hdl, this, "s,-10", &__str_literal_1, DEF_signed_px_get_1_BITS_15_TO_6_2___d33);
    dollar_display(sim_hdl, this);
  }
  INST_col.METH_write(DEF_col_4_PLUS_1___d35);
  if (!(PORT_RST_N == (tUInt8)0u))
    if (DEF_col_4_EQ_63503___d36)
      dollar_finish(sim_hdl, "32", 0u);
}


/* Methods */


/* Reset routines */

void MOD_mkFlowTest::reset_RST_N(tUInt8 ARG_rst_in)
{
  PORT_RST_N = ARG_rst_in;
  INST_px.reset_RST_N(ARG_rst_in);
  INST_load.reset_RST(ARG_rst_in);
  INST_init.reset_RST(ARG_rst_in);
  INST_img.reset_RST(ARG_rst_in);
  INST_cx.reset_RST(ARG_rst_in);
  INST_count.reset_RST(ARG_rst_in);
  INST_col.reset_RST(ARG_rst_in);
  INST_cId.reset_RST(ARG_rst_in);
}


/* Static handles to reset routines */


/* Functions for the parent module to register its reset fns */


/* Functions to set the elaborated clock id */

void MOD_mkFlowTest::set_clk_0(char const *s)
{
  __clk_handle_0 = bk_get_or_define_clock(sim_hdl, s);
}


/* State dumping routine */
void MOD_mkFlowTest::dump_state(unsigned int indent)
{
  printf("%*s%s:\n", indent, "", inst_name);
  INST_cId.dump_state(indent + 2u);
  INST_col.dump_state(indent + 2u);
  INST_count.dump_state(indent + 2u);
  INST_cx.dump_state(indent + 2u);
  INST_img.dump_state(indent + 2u);
  INST_init.dump_state(indent + 2u);
  INST_load.dump_state(indent + 2u);
  INST_px.dump_state(indent + 2u);
}


/* VCD dumping routines */

unsigned int MOD_mkFlowTest::dump_VCD_defs(unsigned int levels)
{
  vcd_write_scope_start(sim_hdl, inst_name);
  vcd_num = vcd_reserve_ids(sim_hdl, 11u);
  unsigned int num = vcd_num;
  for (unsigned int clk = 0u; clk < bk_num_clocks(sim_hdl); ++clk)
    vcd_add_clock_def(sim_hdl, this, bk_clock_name(sim_hdl, clk), bk_clock_vcd_num(sim_hdl, clk));
  vcd_write_def(sim_hdl, bk_clock_vcd_num(sim_hdl, __clk_handle_0), "CLK", 1u);
  vcd_write_def(sim_hdl, num++, "RST_N", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "_0_CONCAT_readInput_cx_5_7___d28", 512u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "px_get___d31", 512u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "x__h678", 32u);
  num = INST_cId.dump_VCD_defs(num);
  num = INST_col.dump_VCD_defs(num);
  num = INST_count.dump_VCD_defs(num);
  num = INST_cx.dump_VCD_defs(num);
  num = INST_img.dump_VCD_defs(num);
  num = INST_init.dump_VCD_defs(num);
  num = INST_load.dump_VCD_defs(num);
  if (levels != 1u)
  {
    unsigned int l = levels == 0u ? 0u : levels - 1u;
    num = INST_px.dump_VCD_defs(l);
  }
  vcd_write_scope_end(sim_hdl);
  return num;
}

void MOD_mkFlowTest::dump_VCD(tVCDDumpType dt, unsigned int levels, MOD_mkFlowTest &backing)
{
  vcd_defs(dt, backing);
  vcd_prims(dt, backing);
  if (levels != 1u)
    vcd_submodules(dt, levels - 1u, backing);
}

void MOD_mkFlowTest::vcd_defs(tVCDDumpType dt, MOD_mkFlowTest &backing)
{
  unsigned int num = vcd_num;
  if (dt == VCD_DUMP_XS)
  {
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 512u);
    vcd_write_x(sim_hdl, num++, 512u);
    vcd_write_x(sim_hdl, num++, 32u);
  }
  else
    if (dt == VCD_DUMP_CHANGES)
    {
      if ((backing.PORT_RST_N) != PORT_RST_N)
      {
	vcd_write_val(sim_hdl, num, PORT_RST_N, 1u);
	backing.PORT_RST_N = PORT_RST_N;
      }
      ++num;
      if ((backing.DEF__0_CONCAT_readInput_cx_5_7___d28) != DEF__0_CONCAT_readInput_cx_5_7___d28)
      {
	vcd_write_val(sim_hdl, num, DEF__0_CONCAT_readInput_cx_5_7___d28, 512u);
	backing.DEF__0_CONCAT_readInput_cx_5_7___d28 = DEF__0_CONCAT_readInput_cx_5_7___d28;
      }
      ++num;
      if ((backing.DEF_px_get___d31) != DEF_px_get___d31)
      {
	vcd_write_val(sim_hdl, num, DEF_px_get___d31, 512u);
	backing.DEF_px_get___d31 = DEF_px_get___d31;
      }
      ++num;
      if ((backing.DEF_x__h678) != DEF_x__h678)
      {
	vcd_write_val(sim_hdl, num, DEF_x__h678, 32u);
	backing.DEF_x__h678 = DEF_x__h678;
      }
      ++num;
    }
    else
    {
      vcd_write_val(sim_hdl, num++, PORT_RST_N, 1u);
      backing.PORT_RST_N = PORT_RST_N;
      vcd_write_val(sim_hdl, num++, DEF__0_CONCAT_readInput_cx_5_7___d28, 512u);
      backing.DEF__0_CONCAT_readInput_cx_5_7___d28 = DEF__0_CONCAT_readInput_cx_5_7___d28;
      vcd_write_val(sim_hdl, num++, DEF_px_get___d31, 512u);
      backing.DEF_px_get___d31 = DEF_px_get___d31;
      vcd_write_val(sim_hdl, num++, DEF_x__h678, 32u);
      backing.DEF_x__h678 = DEF_x__h678;
    }
}

void MOD_mkFlowTest::vcd_prims(tVCDDumpType dt, MOD_mkFlowTest &backing)
{
  INST_cId.dump_VCD(dt, backing.INST_cId);
  INST_col.dump_VCD(dt, backing.INST_col);
  INST_count.dump_VCD(dt, backing.INST_count);
  INST_cx.dump_VCD(dt, backing.INST_cx);
  INST_img.dump_VCD(dt, backing.INST_img);
  INST_init.dump_VCD(dt, backing.INST_init);
  INST_load.dump_VCD(dt, backing.INST_load);
}

void MOD_mkFlowTest::vcd_submodules(tVCDDumpType dt, unsigned int levels, MOD_mkFlowTest &backing)
{
  INST_px.dump_VCD(dt, levels, backing.INST_px);
}
