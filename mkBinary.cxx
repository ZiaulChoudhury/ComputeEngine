/*
 * Generated by Bluespec Compiler (build f2da894e)
 * 
 * On Sat Jul 17 19:53:59 IST 2021
 * 
 */
#include "bluesim_primitives.h"
#include "mkBinary.h"


/* Constructor */
MOD_mkBinary::MOD_mkBinary(tSimStateHdl simHdl, char const *name, Module *parent)
  : Module(simHdl, name, parent),
    __clk_handle_0(BAD_CLOCK_HANDLE),
    INST_cOut(simHdl, "cOut", this, 16u, 0u, (tUInt8)0u),
    INST_op(simHdl, "op", this, 4u, (tUInt8)0u, (tUInt8)0u),
    PORT_RST_N((tUInt8)1u)
{
  symbol_count = 2u;
  symbols = new tSym[symbol_count];
  init_symbols_0();
}


/* Symbol init fns */

void MOD_mkBinary::init_symbols_0()
{
  init_symbol(&symbols[0u], "cOut", SYM_MODULE, &INST_cOut);
  init_symbol(&symbols[1u], "op", SYM_MODULE, &INST_op);
}


/* Rule actions */


/* Methods */

void MOD_mkBinary::METH_a_b(tUInt32 ARG_a_b__a, tUInt32 ARG_a_b__b)
{
  tUInt8 DEF_op_EQ_1_OR_op_EQ_2_OR_op_EQ_3_OR_op_EQ_4_OR_op_ETC___d10;
  tUInt32 DEF_in2_i__h248;
  tUInt32 DEF_in1_i__h233;
  tUInt32 DEF_IF_op_EQ_1_THEN_SEXT_a_b__a_BITS_15_TO_6_1_2_C_ETC___d42;
  tUInt32 DEF_x__h319;
  tUInt32 DEF_x__h338;
  tUInt8 DEF_a_b__a_SLE_a_b__b___d36;
  tUInt32 DEF_x__h311;
  tUInt8 DEF_a_b__a_BIT_15___d21;
  tUInt8 DEF_a_b__b_BIT_15___d22;
  tUInt8 DEF__a_f__h242;
  tUInt8 DEF__b_f__h254;
  tUInt32 DEF__a_i__h241;
  tUInt32 DEF__b_i__h253;
  tUInt32 DEF_x__h225;
  tUInt32 DEF_x_BITS_15_TO_0___h261;
  tUInt32 DEF_x__h274;
  tUInt32 DEF_x_BITS_21_TO_6___h360;
  DEF_b__h134 = INST_op.METH_read();
  DEF__b_i__h253 = (tUInt32)(ARG_a_b__b >> 6u);
  DEF__a_i__h241 = (tUInt32)(ARG_a_b__a >> 6u);
  DEF__b_f__h254 = (tUInt8)((tUInt8)63u & ARG_a_b__b);
  DEF__a_f__h242 = (tUInt8)((tUInt8)63u & ARG_a_b__a);
  DEF_a_b__b_BIT_15___d22 = (tUInt8)(ARG_a_b__b >> 15u);
  DEF_a_b__a_BIT_15___d21 = (tUInt8)(ARG_a_b__a >> 15u);
  DEF_a_b__a_SLE_a_b__b___d36 = primSLE8(1u, 16u, (tUInt32)(ARG_a_b__a), 16u, (tUInt32)(ARG_a_b__b));
  DEF_x__h338 = DEF_a_b__b_BIT_15___d22 ? 65535u & -ARG_a_b__b : ARG_a_b__b;
  DEF_x__h319 = DEF_a_b__a_BIT_15___d21 ? 65535u & -ARG_a_b__a : ARG_a_b__a;
  DEF_x__h311 = DEF_x__h319 * DEF_x__h338;
  DEF_x__h274 = (DEF_a_b__a_BIT_15___d21 && !DEF_a_b__b_BIT_15___d22) || (DEF_a_b__b_BIT_15___d22 && !DEF_a_b__a_BIT_15___d21) ? -DEF_x__h311 : DEF_x__h311;
  DEF_x_BITS_21_TO_6___h360 = (tUInt32)(65535u & (DEF_x__h274 >> 6u));
  DEF_in1_i__h233 = primSignExt32(11u, 10u, (tUInt32)(DEF__a_i__h241));
  DEF_op_EQ_1_OR_op_EQ_2_OR_op_EQ_3_OR_op_EQ_4_OR_op_ETC___d10 = DEF_b__h134 == (tUInt8)1u || (DEF_b__h134 == (tUInt8)2u || (DEF_b__h134 == (tUInt8)3u || (DEF_b__h134 == (tUInt8)4u || DEF_b__h134 == (tUInt8)0u)));
  DEF_in2_i__h248 = primSignExt32(11u, 10u, (tUInt32)(DEF__b_i__h253));
  DEF_x__h225 = 131071u & ((131071u & ((DEF_in1_i__h233 << 6u) | (tUInt32)(DEF__a_f__h242))) + (131071u & ((DEF_in2_i__h248 << 6u) | (tUInt32)(DEF__b_f__h254))));
  DEF_x_BITS_15_TO_0___h261 = (tUInt32)(65535u & DEF_x__h225);
  switch (DEF_b__h134) {
  case (tUInt8)1u:
    DEF_IF_op_EQ_1_THEN_SEXT_a_b__a_BITS_15_TO_6_1_2_C_ETC___d42 = DEF_x_BITS_15_TO_0___h261;
    break;
  case (tUInt8)2u:
    DEF_IF_op_EQ_1_THEN_SEXT_a_b__a_BITS_15_TO_6_1_2_C_ETC___d42 = DEF_x_BITS_21_TO_6___h360;
    break;
  case (tUInt8)3u:
    DEF_IF_op_EQ_1_THEN_SEXT_a_b__a_BITS_15_TO_6_1_2_C_ETC___d42 = DEF_a_b__a_SLE_a_b__b___d36 ? ARG_a_b__b : ARG_a_b__a;
    break;
  case (tUInt8)4u:
    DEF_IF_op_EQ_1_THEN_SEXT_a_b__a_BITS_15_TO_6_1_2_C_ETC___d42 = DEF_a_b__a_SLE_a_b__b___d36 ? ARG_a_b__a : ARG_a_b__b;
    break;
  default:
    DEF_IF_op_EQ_1_THEN_SEXT_a_b__a_BITS_15_TO_6_1_2_C_ETC___d42 = 0u;
  }
  if (DEF_op_EQ_1_OR_op_EQ_2_OR_op_EQ_3_OR_op_EQ_4_OR_op_ETC___d10)
    INST_cOut.METH_write(DEF_IF_op_EQ_1_THEN_SEXT_a_b__a_BITS_15_TO_6_1_2_C_ETC___d42);
}

tUInt8 MOD_mkBinary::METH_RDY_a_b()
{
  tUInt8 PORT_RDY_a_b;
  tUInt8 DEF_CAN_FIRE_a_b;
  DEF_CAN_FIRE_a_b = (tUInt8)1u;
  PORT_RDY_a_b = DEF_CAN_FIRE_a_b;
  return PORT_RDY_a_b;
}

tUInt32 MOD_mkBinary::METH_c()
{
  tUInt32 PORT_c;
  PORT_c = INST_cOut.METH_read();
  return PORT_c;
}

tUInt8 MOD_mkBinary::METH_RDY_c()
{
  tUInt8 PORT_RDY_c;
  tUInt8 DEF_CAN_FIRE_c;
  DEF_CAN_FIRE_c = (tUInt8)1u;
  PORT_RDY_c = DEF_CAN_FIRE_c;
  return PORT_RDY_c;
}

void MOD_mkBinary::METH_set_operation(tUInt8 ARG_set_operation__ox)
{
  INST_op.METH_write(ARG_set_operation__ox);
}

tUInt8 MOD_mkBinary::METH_RDY_set_operation()
{
  tUInt8 PORT_RDY_set_operation;
  tUInt8 DEF_CAN_FIRE_set_operation;
  DEF_CAN_FIRE_set_operation = (tUInt8)1u;
  PORT_RDY_set_operation = DEF_CAN_FIRE_set_operation;
  return PORT_RDY_set_operation;
}

tUInt8 MOD_mkBinary::METH_get_operation()
{
  tUInt8 PORT_get_operation;
  DEF_b__h134 = INST_op.METH_read();
  PORT_get_operation = DEF_b__h134;
  return PORT_get_operation;
}

tUInt8 MOD_mkBinary::METH_RDY_get_operation()
{
  tUInt8 PORT_RDY_get_operation;
  tUInt8 DEF_CAN_FIRE_get_operation;
  DEF_CAN_FIRE_get_operation = (tUInt8)1u;
  PORT_RDY_get_operation = DEF_CAN_FIRE_get_operation;
  return PORT_RDY_get_operation;
}


/* Reset routines */

void MOD_mkBinary::reset_RST_N(tUInt8 ARG_rst_in)
{
  PORT_RST_N = ARG_rst_in;
  INST_op.reset_RST(ARG_rst_in);
  INST_cOut.reset_RST(ARG_rst_in);
}


/* Static handles to reset routines */


/* Functions for the parent module to register its reset fns */


/* Functions to set the elaborated clock id */

void MOD_mkBinary::set_clk_0(char const *s)
{
  __clk_handle_0 = bk_get_or_define_clock(sim_hdl, s);
}


/* State dumping routine */
void MOD_mkBinary::dump_state(unsigned int indent)
{
  printf("%*s%s:\n", indent, "", inst_name);
  INST_cOut.dump_state(indent + 2u);
  INST_op.dump_state(indent + 2u);
}


/* VCD dumping routines */

unsigned int MOD_mkBinary::dump_VCD_defs(unsigned int levels)
{
  vcd_write_scope_start(sim_hdl, inst_name);
  vcd_num = vcd_reserve_ids(sim_hdl, 4u);
  unsigned int num = vcd_num;
  for (unsigned int clk = 0u; clk < bk_num_clocks(sim_hdl); ++clk)
    vcd_add_clock_def(sim_hdl, this, bk_clock_name(sim_hdl, clk), bk_clock_vcd_num(sim_hdl, clk));
  vcd_write_def(sim_hdl, bk_clock_vcd_num(sim_hdl, __clk_handle_0), "CLK", 1u);
  vcd_write_def(sim_hdl, num++, "RST_N", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "b__h134", 4u);
  num = INST_cOut.dump_VCD_defs(num);
  num = INST_op.dump_VCD_defs(num);
  vcd_write_scope_end(sim_hdl);
  return num;
}

void MOD_mkBinary::dump_VCD(tVCDDumpType dt, unsigned int levels, MOD_mkBinary &backing)
{
  vcd_defs(dt, backing);
  vcd_prims(dt, backing);
}

void MOD_mkBinary::vcd_defs(tVCDDumpType dt, MOD_mkBinary &backing)
{
  unsigned int num = vcd_num;
  if (dt == VCD_DUMP_XS)
  {
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 4u);
  }
  else
    if (dt == VCD_DUMP_CHANGES)
    {
      if ((backing.PORT_RST_N) != PORT_RST_N)
      {
	vcd_write_val(sim_hdl, num, PORT_RST_N, 1u);
	backing.PORT_RST_N = PORT_RST_N;
      }
      ++num;
      if ((backing.DEF_b__h134) != DEF_b__h134)
      {
	vcd_write_val(sim_hdl, num, DEF_b__h134, 4u);
	backing.DEF_b__h134 = DEF_b__h134;
      }
      ++num;
    }
    else
    {
      vcd_write_val(sim_hdl, num++, PORT_RST_N, 1u);
      backing.PORT_RST_N = PORT_RST_N;
      vcd_write_val(sim_hdl, num++, DEF_b__h134, 4u);
      backing.DEF_b__h134 = DEF_b__h134;
    }
}

void MOD_mkBinary::vcd_prims(tVCDDumpType dt, MOD_mkBinary &backing)
{
  INST_cOut.dump_VCD(dt, backing.INST_cOut);
  INST_op.dump_VCD(dt, backing.INST_op);
}
