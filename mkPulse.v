//
// Generated by Bluespec Compiler (build 00185f79)
//
// On Fri Jun 18 20:19:37 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_send                       O     1 const
// isvalid                        O     1
// RDY_isvalid                    O     1 const
// RDY_ishigh                     O     1
// RDY_clean                      O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// EN_send                        I     1
// EN_ishigh                      I     1
// EN_clean                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPulse(CLK,
	       RST_N,

	       EN_send,
	       RDY_send,

	       isvalid,
	       RDY_isvalid,

	       EN_ishigh,
	       RDY_ishigh,

	       EN_clean,
	       RDY_clean);
  input  CLK;
  input  RST_N;

  // action method send
  input  EN_send;
  output RDY_send;

  // value method isvalid
  output isvalid;
  output RDY_isvalid;

  // action method ishigh
  input  EN_ishigh;
  output RDY_ishigh;

  // action method clean
  input  EN_clean;
  output RDY_clean;

  // signals for module outputs
  wire RDY_clean, RDY_ishigh, RDY_isvalid, RDY_send, isvalid;

  // register port_0
  reg port_0;
  reg port_0$D_IN;
  wire port_0$EN;

  // register port_1
  reg port_1;
  reg port_1$D_IN;
  wire port_1$EN;

  // register readCounter
  reg readCounter;
  wire readCounter$D_IN, readCounter$EN;

  // register writeCounter
  reg writeCounter;
  wire writeCounter$D_IN, writeCounter$EN;

  // inputs to muxes for submodule ports
  wire MUX_port_0$write_1__SEL_2,
       MUX_port_0$write_1__SEL_3,
       MUX_port_1$write_1__SEL_2,
       MUX_port_1$write_1__SEL_3,
       MUX_readCounter$write_1__VAL_2,
       MUX_writeCounter$write_1__VAL_2;

  // action method send
  assign RDY_send = 1'd1 ;

  // value method isvalid
  assign isvalid = port_0 || port_1 ;
  assign RDY_isvalid = 1'd1 ;

  // action method ishigh
  assign RDY_ishigh = port_0 || port_1 ;

  // action method clean
  assign RDY_clean = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_port_0$write_1__SEL_2 = EN_send && writeCounter == 1'd0 ;
  assign MUX_port_0$write_1__SEL_3 = EN_ishigh && readCounter == 1'd0 ;
  assign MUX_port_1$write_1__SEL_2 = EN_send && writeCounter == 1'd1 ;
  assign MUX_port_1$write_1__SEL_3 = EN_ishigh && readCounter == 1'd1 ;
  assign MUX_readCounter$write_1__VAL_2 = readCounter + 1'd1 ;
  assign MUX_writeCounter$write_1__VAL_2 = writeCounter + 1'd1 ;

  // register port_0
  always@(EN_clean or MUX_port_0$write_1__SEL_2 or MUX_port_0$write_1__SEL_3)
  case (1'b1)
    EN_clean: port_0$D_IN = 1'd0;
    MUX_port_0$write_1__SEL_2: port_0$D_IN = 1'd1;
    MUX_port_0$write_1__SEL_3: port_0$D_IN = 1'd0;
    default: port_0$D_IN = 1'b0 /* unspecified value */ ;
  endcase
  assign port_0$EN =
	     EN_send && writeCounter == 1'd0 ||
	     EN_ishigh && readCounter == 1'd0 ||
	     EN_clean ;

  // register port_1
  always@(EN_clean or MUX_port_1$write_1__SEL_2 or MUX_port_1$write_1__SEL_3)
  case (1'b1)
    EN_clean: port_1$D_IN = 1'd0;
    MUX_port_1$write_1__SEL_2: port_1$D_IN = 1'd1;
    MUX_port_1$write_1__SEL_3: port_1$D_IN = 1'd0;
    default: port_1$D_IN = 1'b0 /* unspecified value */ ;
  endcase
  assign port_1$EN =
	     EN_send && writeCounter == 1'd1 ||
	     EN_ishigh && readCounter == 1'd1 ||
	     EN_clean ;

  // register readCounter
  assign readCounter$D_IN = !EN_clean && MUX_readCounter$write_1__VAL_2 ;
  assign readCounter$EN = EN_ishigh || EN_clean ;

  // register writeCounter
  assign writeCounter$D_IN = !EN_clean && MUX_writeCounter$write_1__VAL_2 ;
  assign writeCounter$EN = EN_send || EN_clean ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        port_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	port_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	readCounter <= `BSV_ASSIGNMENT_DELAY 1'd0;
	writeCounter <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (port_0$EN) port_0 <= `BSV_ASSIGNMENT_DELAY port_0$D_IN;
	if (port_1$EN) port_1 <= `BSV_ASSIGNMENT_DELAY port_1$D_IN;
	if (readCounter$EN)
	  readCounter <= `BSV_ASSIGNMENT_DELAY readCounter$D_IN;
	if (writeCounter$EN)
	  writeCounter <= `BSV_ASSIGNMENT_DELAY writeCounter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    port_0 = 1'h0;
    port_1 = 1'h0;
    readCounter = 1'h0;
    writeCounter = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkPulse

